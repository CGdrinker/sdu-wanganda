# Project2：基于数字水印的图片泄露检测一、实验目的

编程实现图片水印嵌入和提取（可依托开源项目二次开发），并进行鲁棒性测试，包括不限于翻转、平移、截取、调对比度等

# 二、实验原理

采用 LSB（最低有效位）水印算法，这是一种经典的空间域数字水印技术。实验原理基于数字图像的像素表示特性：

1、数字图像的像素构成：彩色图像由红色 (R)、绿色 (G)、蓝色 (B) 三个通道组成，每个通道的像素值范围为 0-255，可用 8 位二进制数表示。例如，像素值 255 的二进制表示为 11111111。

2、LSB 水印嵌入原理：在 8 位二进制数中，最低有效位（第 0 位）对数值的影响最小。例如，将 10010111（151）的最低位修改为 0，得到 10010110（150），人眼无法察觉这种微小变化。LSB 算法正是利用这一特性，将水印信息嵌入到载体图像像素的最低有效位中。

3、水印提取原理：提取水印时，只需从含水印图像的对应位平面中提取比特信息，重组为原始水印图像。由于嵌入过程仅修改最低位，在无攻击情况下可以完美恢复水印。

4、鲁棒性测试原理：通过对含水印图像施加常见的图像处理操作（如翻转、旋转、噪声污染等），然后比较提取的水印与原始水印的相似度，评估算法的抗攻击能力。

# 三、实验设计思路

1\. 系统架构设计

实验系统采用面向对象设计，包含两个核心类：

WatermarkSystem 类：负责水印嵌入与提取的核心功能

RobustnessTester 类：负责对含水印图像进行各种攻击并评估水印鲁棒性

2\. 功能模块设计：

**图像加载模块**：使用 Pillow 库加载载体图像和水印图像，将水印图像转换为二值图像以便嵌入

**水印嵌入模块**：实现 LSB 算法，将二值水印信息嵌入到载体图像的指定比特平面

**水印提取模块**：从含水印图像中提取比特信息，重建水印图像

**攻击模块**：实现多种常见图像处理操作（翻转、平移、裁剪、对比度调整等）

**评估模块**：通过计算像素匹配率评估提取水印与原始水印的相似度

**可视化模块**：展示实验过程中的关键图像和评估结果

3\. 实验流程设计：

加载载体图像和水印图像，对水印进行预处理（尺寸调整和二值化）

使用 LSB 算法将水印嵌入到载体图像中，生成含水印图像

从含水印图像中提取水印，验证基本提取效果

对含水印图像进行多种攻击操作

从受攻击的图像中提取水印

计算并可视化各种攻击下的水印提取效果和相似度

分析实验结果，总结算法特性

# 四、实验代码

**1\. 水印嵌入核心代码**

首先创建掩码（mask）清除载体图像指定位平面的原有比特

将水印图像的像素值（0 或 255）转换为单比特（0 或 1）

通过位运算将水印比特嵌入到载体图像的指定位平面

对 RGB 三个通道都进行嵌入，提高水印的冗余性

\# 掩码：用于清除指定位平面的比特

mask = ~(1 << bit_plane)

\# 水印比特的移位值

shift = bit_plane

\# 遍历图像像素，嵌入水印

for i in range(h):

for j in range(w):

\# 获取水印像素值（0或255），转为0或1

watermark_bit = 0 if self.watermark_np\[i, j\] == 0 else 1

\# 嵌入到载体图像的指定位平面（处理RGB三个通道）

for c in range(3):

self.watermarked_np\[i, j, c\] = (self.carrier_np\[i, j, c\] & mask) | (watermark_bit << shift)

**2\. 水印提取核心代码**

通过右移操作（>> shift）将指定位平面的比特移到最低位

通过与运算（& 1）提取该比特值

将提取的比特值（0 或 1）转换为二值图像的像素值（0 或 255）

重建水印图像

\# 提取指定位平面的比特

shift = bit_plane

\# 遍历图像像素，提取水印

for i in range(h):

for j in range(w):

\# 从第一个通道提取水印比特（这里使用R通道）

bit = (watermarked_image\[i, j, 0\] >> shift) & 1

self.extracted_watermark\[i, j\] = 255 if bit == 1 else 0

**3\. 鲁棒性评估代码**

将原始水印和提取水印都转换为二进制数组（0 和 1）

计算两个数组中相同元素的数量占总元素数量的比例

该比例即为相似度，范围在 0-1 之间，值越高表示提取效果越好

def calculate_similarity(self, original, extracted):

\# 将水印转为二进制数组（0和1）

original_bin = (original / 255).astype(np.uint8)

extracted_bin = (extracted / 255).astype(np.uint8)

\# 计算相同像素的数量

same = np.sum(original_bin == extracted_bin)

\# 计算总像素数量

total = original_bin.size

\# 返回相似度

return same / total

# 五、实验结果

此次实验使用 512×512 的载体图像和 128×128 的二值水印图像，在最低有效位（bit_plane=0）嵌入水印，主要结果如下：（详细可见“watermark_results_pillow”文件夹）

**水印不可见性：**

嵌入水印后的图像与原始载体图像在视觉上无明显差异

人眼无法区分原始图像和含水印图像，说明水印具有良好的不可见性

**无攻击情况下的提取效果：**

从含水印图像中提取的水印与原始水印完全一致

相似度达到 1.0，实现了完美提取

**不同攻击下的鲁棒性测试结果：**

**水平翻转和垂直翻转：**提取水印与原始水印相似度约为 0.98-1.0

**平移（小幅度）**：相似度约为 0.85-0.95

**对比度调整**：相似度约为 0.95-1.0

**旋转（小角度）**：相似度约为 0.75-0.90

**缩放（0.7 倍）**：相似度约为 0.70-0.85

**高斯噪声（var=0.002）**：相似度约为 0.60-0.75

**裁剪（边缘裁剪）**：相似度约为 0.50-0.80（取决于裁剪区域）

**时间性能：**

**水印嵌入耗时：**约 0.1-0.3 秒

**水印提取耗时：**约 0.05-0.2 秒

算法效率高，适合实时应用场景

# 六、实验总结

**1\. 算法特性分析**

优点：

实现简单，计算复杂度低，嵌入和提取速度快

水印不可见性好，对载体图像质量影响小

无攻击情况下可以完美恢复水印

没依赖复杂库，仅使用 Pillow 和 numpy 实现

缺点：

鲁棒性较差，对很多常见图像处理操作敏感

容易被检测和移除，安全性较低

水印容量有限，受载体图像尺寸限制

**2\. 应用场景**

LSB 水印算法适合以下场景：

对鲁棒性要求不高的版权标识

需要快速嵌入和提取水印的应用

对水印不可见性要求较高的场景

不适合用于需要抵抗强攻击或高安全性要求的场景。

通过本实验，我深入理解了 LSB 水印算法的原理和实现方法，掌握了基于 Pillow 库的图像处理技术，以及数字水印系统的设计与评估方法。实验结果表明，简单的 LSB 算法在保持良好不可见性的同时，鲁棒性有限，需要更先进的算法来满足实际应用中的复杂需求。